searchState.loadedDescShard("polars_core", 0, "Enable the global string cache as long as the object is …\nAsserts that two expressions of type <code>DataFrame</code> are equal …\nThe typed heart of every Series column.\nData types supported by Polars.\nDisable and clear the global string cache.\nApply a macro on the Downcasted ChunkedArrays of DataTypes …\nApply a macro on the Downcasted ChunkedArrays of DataTypes …\nEnable the global string cache.\nDataFrame module.\nReturns the argument unchanged.\nFunctions\nHold the StringCache\nCalls <code>U::from(self)</code>.\nApply a macro on the Downcasted ChunkedArrays\nApply a macro on the Series\nApply a macro on the Series\nEverything you need to get started with Polars.\nType agnostic columnar data structure.\nTesting utilities.\nCheck whether the global string cache is enabled.\nChunkedArray\nReturns whether all values in the array are <code>true</code>.\nReturns whether all values in the column are <code>true</code>.\nThis is an iterator over a <code>ListChunked</code> that saves …\nThis is an iterator over a <code>ArrayChunked</code> that save …\nSee <code>amortized_iter</code>.\nThis is an iterator over a <code>ArrayChunked</code> that save …\nReturns whether any of the values in the column are <code>true</code>.\nReturns whether any of the values in the column are <code>true</code>.\nAppend in place. This is done by adding the chunks of <code>other</code>…\nAppend in place. This is done by adding the chunks of <code>other</code>…\nApply a closure <code>F</code> elementwise.\nApply a closure <code>F</code> elementwise.\nApply a closure <code>F</code> elementwise.\nApply a closure <code>F</code> to each array.\nCast a numeric array to another numeric data type and …\nApplies a function only to the non-null elements, …\nIgnore the list indices and apply <code>func</code> to the inner type …\nIgnore the list indices and apply <code>func</code> to the inner type …\nSafety\nPanics\nImplementations of arithmetic operations on ChunkedArrays.\nImplementations of the ChunkCast Trait.\nCast a numeric array to another numeric data type and …\nReturns an iterator over the lengths of the chunks of the …\nA reference to the chunks\nA mutable reference to the chunks\nMethods for collecting into a ChunkedArray.\nReturns the values of the array as a contiguous slice.\nGet slices of the underlying arrow data. NOTE: null values …\nGet data type of <code>ChunkedArray</code>.\nExtend the memory backed by this array with the values …\nGet the index of the first non null value in this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>ChunkedArray</code> from existing chunks.\nCreate a new <code>ChunkedArray</code> from existing chunks.\nCreate a new ChunkedArray from an iterator.\nImplementations of upstream traits for <code>ChunkedArray&lt;T&gt;</code>\nConvert a non-logical <code>ListChunked</code> back into a logical …\nConvert a non-logical <code>ArrayChunked</code> back into a logical …\nCreate a new ChunkedArray by taking ownership of the Vec. …\nCreate a new ChunkedArray from a Vec and a validity mask.\nGet a single value from this <code>ChunkedArray</code>. If the return …\nGet the inner values as <code>Series</code>\nGet the inner values as <code>Series</code>, ignoring the list offsets.\nRecurse nested types until we are at the leaf array.\nGet a hold to an object that can be formatted or …\nGet a hold to an object that can be formatted or …\nGet a single value from this <code>ChunkedArray</code>. If the return …\nUse the indexes as perfect groups.\nReturn if any the chunks in this <code>ChunkedArray</code> have nulls.\nGet the head of the <code>ChunkedArray</code>\nGet the inner data type of the list.\nGet the inner data type of the fixed size list.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if ChunkedArray is empty.\nGet a mask of the valid values.\nGet a mask of the null values.\nReturns true if contains a single chunk and has no null …\nGet the buffer of bits representing null values\nGet the index of the last non null value in this …\nGet the length of the ChunkedArray\nApply lhs / self\nApply lhs % self\nApply lhs - self\nTake a view of top n elements\nCreate a temporary <code>ChunkedArray</code> from a slice.\nCreate a temporary <code>ChunkedArray</code> from a slice.\nName of the <code>ChunkedArray</code>.\nSpecialization that prevents an allocation prefer this …\nCreate a new <code>ChunkedArray</code> and explicitly set its <code>length</code> …\nConvert missing values to <code>NaN</code> values.\nReturn the number of null values in the ChunkedArray.\nTraits for miscellaneous operations on ChunkedArray\nRemove empty chunks.\nCreate <code>ChunkedArray</code> with samples from a Bernoulli …\nCreate <code>ChunkedArray</code> with samples from a Normal …\nCreate <code>ChunkedArray</code> with samples from a Standard Normal …\nCreate <code>ChunkedArray</code> with samples from a Uniform …\nRechunks this ChunkedArray, returning a new Cow::Owned …\nRechunks this ChunkedArray in-place.\nGet a reference to the field.\nRename this <code>ChunkedArray</code>.\nApply a rolling custom function. This is pretty slow …\nApply a rolling custom function. This is pretty slow …\nSample a fraction between 0.0-1.0 of this <code>ChunkedArray</code>.\nSample n datapoints from this <code>ChunkedArray</code>.\nSet the null count directly.\nSet the ‘sorted’ bit meta info.\nShrink the capacity of this array to fit its length.\nSlice the array. The chunks are reallocated the underlying …\nSplit the array. The chunks are reallocated the underlying …\nGet the tail of the <code>ChunkedArray</code>\nGather values from ChunkedArray by index.\nGather values from ChunkedArray by index.\nGather values from ChunkedArray by index.\nGather values from ChunkedArray by index.\nTraits and utilities for temporal data.\nConvert an <code>StringChunked</code> to a <code>Series</code> of <code>DataType::Decimal</code>. …\nSafety\nSet the logical type of the <code>ListChunked</code>.\nIf all nested <code>Series</code> have the same length, a 2 dimensional …\nIf data is aligned in a single chunk and has no Null …\nConvert the datatype of the list into the physical …\nConvert the datatype of the array into the physical …\nSafety\nConvert to a <code>Vec</code> of <code>Option&lt;T::Native&gt;</code>.\nConvert to a <code>Vec</code> but don’t return <code>Option&lt;T::Native&gt;</code> if …\nTry apply a closure <code>F</code> elementwise.\nTry apply a closure <code>F</code> to each array.\nApplies a function only to the non-null elements, …\nSeries to <code>ChunkedArray&lt;T&gt;</code>\nGet a single value from this <code>ChunkedArray</code>. Null values are …\nSafety\nReturn this <code>ChunkedArray</code> with a new name.\nSet the ‘sorted’ bit meta info.\nZip with a <code>ChunkedArray</code> then apply a binary function <code>F</code> …\nZip with a <code>ChunkedArray</code> then apply a binary function <code>F</code> …\nAppends a null slot into the builder\nAppends a null slot into the builder\nAppends a null slot into the builder\nAppends a null slot into the builder\nAppends a value of type <code>T</code> into the builder\nAppends a value of type <code>T</code> into the builder\nAppends a value of type <code>T</code> into the builder\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new ChunkedArray from an iterator.\nCreate a new ChunkedArray from an iterator.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new BinViewChunkedBuilder\nAppends from an iterator over values\nAppends from an iterator over values\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOverflow is replaced with null\nAllows wrapping overflow\nRaises on overflow\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn interior mutable version of <code>StatisticsFlags</code>\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe no null iterator for a <code>BooleanArray</code>\nA <code>PolarsIterator</code> is an iterator over a <code>ChunkedArray</code> which …\nWrapper struct to convert an iterator of type <code>T</code> into one …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ncreate a new iterator\ncreate a new iterator\nValues need to implement this so that they can be stored …\nTrimmed down object safe polars object\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck validity\nCheck validity\nReturns an iterator of <code>Option&lt;&amp;T&gt;</code> over every element of …\nThis is a heap allocated utility that can be used to …\nControl whether extension types may be created.\nSets the validity of this array.\nThis should be used as type information. Consider this a …\nGet a value at a certain index location\nGet a value at a certain index location\nReturns this array with a new validity.\nAppends a null slot into the builder\nAppends a value of type <code>T</code> into the builder\nReturns the argument unchanged.\nSafety\nCalls <code>U::from(self)</code>.\nThis trait can be registered, after which that global …\nTakes a <code>name</code> and <code>capacity</code> and constructs a new builder.\nAppend a <code>null</code> value.\nAppend a <code>T</code> of <code>ObjectChunked&lt;T&gt;</code> made generic via the <code>Any</code> …\nA function that creates an object builder\nReturns the argument unchanged.\nSafety\nCalls <code>U::from(self)</code>.\nTake the current state and materialize as a <code>Series</code> the …\nprevious value in array\nAggregation operations.\nFastest way to do elementwise operations on a …\nApply kernels on the arrow array chunks in a ChunkedArray.\nCast <code>ChunkedArray&lt;T&gt;</code> to <code>ChunkedArray&lt;N&gt;</code>\nCompare <code>Series</code> and <code>ChunkedArray</code>’s and get a <code>boolean</code> mask …\nCompare <code>Series</code> and <code>ChunkedArray</code>’s using inequality …\nCreate a new ChunkedArray filled with values at that index.\nExplode/flatten a List or String Series\nReplace None values with a value\nFilter values by a boolean mask.\nFill a ChunkedArray with one value.\nQuantile and median aggregation.\nReverse a <code>ChunkedArray&lt;T&gt;</code>\nThis differs from ChunkWindowCustom and ChunkWindow by not …\nCreate a <code>ChunkedArray</code> with new values by index or by …\nShift the values of a <code>ChunkedArray</code> by a number of periods.\nSort operations on <code>ChunkedArray</code>.\nGet unique values in a <code>ChunkedArray</code>\nVariance and standard deviation aggregation.\nCombine two <code>ChunkedArray</code> based on some predicate.\nnext value in array\nMask the first unique values as <code>true</code>\nMask the last unique values as <code>true</code>\nmaximum value in array\nmean value of array\nminimal value in array\nNo value.\nreplace with the value one\nSome value of type <code>T</code>.\nreplace with the value zero\nMeant for internal use. In very rare conditions this can …\nApply a closure elementwise including null values.\nApply kernel and return result as a new ChunkedArray.\nApply a kernel that outputs an array of different type.\nApply a closure elementwise and write results to a mutable …\nApply a closure elementwise. This is fastest when the null …\nRetrieve the indexes needed to sort this array.\nRetrieve the indexes need to sort this and the other …\nGet first index of the unique values in a <code>ChunkedArray</code>. …\nCast a <code>ChunkedArray</code> to <code>DataType</code>\nDoes not check if the cast is a valid one and may …\nCast a <code>ChunkedArray</code> to <code>DataType</code>\nCheck for equality.\nCheck for equality where <code>None == None</code>.\nReplace None values with a give value <code>T</code>.\nFilter values in the ChunkedArray with a boolean mask.\nReturns the argument unchanged.\nCreate a ChunkedArray with a single value.\nGet a single value. Beware this is slow.\nGet a single value. Beware this is slow. If you need to …\nGreater than comparison.\nGreater than or equal comparison.\nCalls <code>U::from(self)</code>.\nLess than comparison.\nLess than or equal comparison\nReturns the maximum value in the array, according to the …\nReturns the mean value in the array. Returns <code>None</code> if the …\nReturns the mean value in the array. Returns <code>None</code> if the …\nNumber of unique values in the <code>ChunkedArray</code>\nCreate a new ChunkedArray filled with values at that index.\nCheck for inequality.\nCheck for inequality where <code>None == None</code>.\nAggregate a given quantile of the ChunkedArray. Returns …\nReturn a reversed version of this array.\nSet the values at indexes <code>idx</code> to some optional value …\nSet the values at indexes <code>idx</code> by applying a closure to …\nSet the values where the mask evaluates to <code>true</code> to some …\nShift the values by a given period and fill the parts that …\nReturned a sorted <code>ChunkedArray</code>.\nCompute the standard deviation of this ChunkedArray/Series.\nAggregate the sum of the ChunkedArray. Returns <code>None</code> if not …\nGather values from ChunkedArray by index.\nGather values from ChunkedArray by index.\nGet unique values of a ChunkedArray\nCompute the variance of this ChunkedArray/Series.\nCreate a new ChunkedArray with values from self where the …\nApplies a kernel that produces <code>Array</code> types.\nApply elementwise binary function which produces string, …\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>ArrayRef</code> of the same type.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>ArrayRef</code> of the same type.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>Array</code> types.\nSafety\nSafety\nGet the <code>RowEncodingContext</code> for a certain <code>DataType</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSearch through a series of chunks for the first position …\nUtility trait to slice concrete arrow arrays whilst …\nSlices this <code>Array</code>.\nSlices the <code>Array</code>.\nReturn the indices of the bottom k elements.\nUtility trait to slice concrete arrow arrays whilst …\nSort options for multi-series sorting.\nOptions for single series sorting.\nIf true sort in descending order. Default <code>false</code>.\nOrder of the columns. Default all `false``.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLimit a sort output, this is for optimization purposes and …\nLimit a sort output, this is for optimization purposes and …\nIf true maintain the order of equal elements. Default <code>false</code>…\nWhether maintain the order of equal elements. Default <code>false</code>…\nIf true sort in multiple threads. Default <code>true</code>.\nWhether sort in multiple threads. Default <code>true</code>.\nCreate <code>SortOptions</code> with default values.\nCreate <code>SortMultipleOptions</code> with default values.\nWhether place null values last. Default <code>false</code>.\nWhether place null values last. Default <code>false</code>.\nSlices this <code>Array</code>.\nSlices the <code>Array</code>.\nWhether maintain the order of equal elements. Default <code>false</code>…\nWhether to maintain the order of equal elements. Default …\nWhether sort in multiple threads. Default <code>true</code>.\nWhether to sort in multiple threads. Default <code>true</code>.\nWhether place null values last. Default <code>false</code>.\nWhether to place null values last. Default <code>false</code>.\nSpecify whether to place nulls last, per-column. Defaults …\nSpecify sorting order for the column. Default <code>false</code>.\nSort order for all columns. Default <code>false</code> which is …\nSpecify order for each column. Defaults all <code>false</code>.\nReverse the order of sorting.\nReverse the order of sorting for each column.\nPrints a log message if sensitive verbose logging has been …\nA nested list with a fixed size in each row\nThe set of supported logical types in this crate.\nThe time units defined in Arrow.\nOpaque binary data of variable length whose offsets are …\nA binary type that inlines small values and can intern …\nA binary true or false.\n<code>true</code> and <code>false</code>.\nA 32-bit date representing the elapsed time since UNIX …\nAn <code>i32</code> representing the elapsed time since UNIX epoch …\nAn <code>i64</code> representing the elapsed time since UNIX epoch …\nA 64-bit date representing the elapsed time since UNIX …\nA 128-bit fixed point decimal number with a scale.\nFixed point decimal type optional precision and …\nDecimal value with precision and scale precision is the …\nDecimal backed by 256 bits\nA dictionary encoded array (<code>key_type</code>, <code>value_type</code>), where …\n64-bit integer representing difference between times in …\nMeasure of elapsed time. This elapsed time is a physical …\nExtension type.\nCharacterizes the name and the <code>DataType</code> of a column.\nOpaque binary data of fixed size. Enum parameter specifies …\nA list of some logical data type with a fixed number of …\nAn 16-bit float\nA 32-bit floating point number.\nA <code>f32</code>\nA 64-bit floating point number.\nA <code>f64</code>\nHashmap: maps the indexes from the global …\nA 128-bit integer number.\nAn <code>i128</code>\nA 16-bit integer number.\nAn <code>i16</code>\nA 32-bit integer number.\nAn <code>i32</code>\nA 64-bit integer number.\nAn <code>i64</code>\nAn 8-bit integer number.\nAn <code>i8</code>\nA “calendar” interval modeling elapsed time that takes …\nOpaque binary data of variable length whose offsets are …\nA list of some logical data type whose offsets are …\nA variable-length UTF-8 encoded string whose offsets are …\nNested type, contains arrays that are filled with one of …\nA nested list with a variable size in each row\nA list of some logical data type whose offsets are …\nUtf8Array: caches the string values and a hash of all …\nMaps a logical type to a chunked array implementation of …\nA nested type that is represented as\nTime in microseconds.\nTime in milliseconds.\nTime in nanoseconds.\nNull type\nCan be used to fmt and implements Any, so can be …\nA generic type that can be used in a <code>Series</code> &amp;’static str …\nThis hashmap uses an IdHasher\nString type that inlines small strings.\nSafety\nA dimension in a reshape.\nTime in seconds.\nA UTF8 encoded string type.\nString data\nAn UTF8 encoded string type.\nA nested <code>ArrowDataType</code> with a given number of <code>Field</code>s.\nA 64-bit time representing the elapsed time since midnight …\nA 32-bit time representing the elapsed time since midnight …\nA 64-bit time representing the elapsed time since midnight …\nA <code>i64</code> representing a timestamp measured in <code>TimeUnit</code> with …\nAn unsigned 16-bit integer number.\nAn <code>u16</code>\nAn unsigned 32-bit integer number.\nAn <code>u32</code>\nAn unsigned 64-bit integer number.\nAn <code>u64</code>\nAn unsigned 8-bit integer number.\nAn <code>u8</code>\nA nested datatype that can represent slots of differing …\nA type unknown to Arrow.\nA variable-length UTF-8 encoded string whose offsets are …\nA string type that inlines small values and can intern …\nTrue if all categories are represented in this array. When …\nSet <code>FAST_UNIQUE</code> metadata\nReturns whether all values in the array are <code>true</code>.\nReturns whether all values in the column are <code>true</code>.\nThis is an iterator over a <code>ArrayChunked</code> that save …\nThis is an iterator over a <code>ListChunked</code> that saves …\nThis is an iterator over a <code>ArrayChunked</code> that save …\nSee <code>amortized_iter</code>.\nReturns whether any of the values in the column are <code>true</code>.\nReturns whether any of the values in the column are <code>true</code>.\nApply a closure <code>F</code> elementwise.\nApply a closure <code>F</code> elementwise.\nApply a closure <code>F</code> elementwise.\nApply a closure <code>F</code> to each array.\nIgnore the list indices and apply <code>func</code> to the inner type …\nIgnore the list indices and apply <code>func</code> to the inner type …\nApply a closure <code>F</code> elementwise.\nSafety\nRetrieve the indexes needed to sort this array.\nPanics\nPanics\nGet the inner data type of a multidimensional array.\nReturn whether the cast to <code>to</code> makes sense.\nCan the <code>AnyValue</code> exist as having <code>dtype</code> as its <code>DataType</code>.\nCast the leaf types of Lists/Arrays and keep the nesting.\nSets the <code>Field</code> datatype.\nCheck (recursively) whether datatype contains an …\nGet data type of <code>ChunkedArray</code>.\nGet the matching <code>DataType</code> for this <code>AnyValue</code>`.\nReturns a reference to the <code>Field</code> datatype.\n<code>str</code> to <code>Categorical</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>CategoricalChunked</code> from a physical array and …\nCreate a <code>CategoricalChunked</code> from an array of <code>idx</code> and an …\nCreate a <code>CategoricalChunked</code> from a categorical indices. …\nCreate a new ChunkedArray from an iterator.\nCreate a new ChunkedArray from an iterator.\nCreate a new ChunkedArray from an iterator.\nCreate a new ChunkedArray from an iterator.\nConvert a non-logical <code>ArrayChunked</code> back into a logical …\nConvert a non-logical <code>ListChunked</code> back into a logical …\nCreate a <code>CategoricalChunked</code> from a fixed list of …\n<code>Categorical</code> to <code>str</code>\nGets <code>AnyValue</code> from <code>LogicalType</code>\nGets <code>AnyValue</code> from <code>LogicalType</code>\nSafety\nSafety\nGet the categories in this <code>RevMapping</code>\nGet the inner values as <code>Series</code>\nGet the inner values as <code>Series</code>, ignoring the list offsets.\nRecurse nested types until we are at the leaf array.\nGet a hold to an object that can be formatted or …\nGet a hold to an object that can be formatted or …\nGet a reference to the mapping of categorical types to the …\nGet the full shape of a multidimensional array.\nGet a reference to the <code>&amp;str</code> contained within <code>AnyValue</code>.\nSafety\nSafety\nGet the inner data type of the fixed size list.\nGet the inner data type of the list.\nGet the inner data type of a nested type.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTry to coerce to an AnyValue with static lifetime. This …\nCheck if this <code>DataType</code> is an array.\nCheck if this <code>DataType</code> is a boolean.\nCheck if this <code>DataType</code> is a Decimal type (of any …\nCheck if this <code>DataType</code> is a basic floating point type …\nCheck if this <code>DataType</code> is an integer. Note, this also …\nCheck if the whole dtype is known.\nCheck if this <code>DataType</code> is a list.\nCheck if this <code>DataType</code> is a logical type\nCheck if type is sortable\nCheck if datatype is a primitive type. By that we mean that\nCheck if this <code>DataType</code> is a primitive numeric type …\nCheck if this <code>DataType</code> is a struct\nCheck if this <code>DataType</code> is a temporal type\nCreate an <code>Iterator</code> that iterates over the <code>&amp;str</code> values of …\nGet the absolute inner data type of a nested type.\nGet the length of the <code>RevMapping</code>\nAnswers if this type matches the given type of a schema.\nMaterialize this datatype if it is unknown. All other …\nTry to get the maximum value for this datatype.\nTry to get the minimum value for this datatype.\nCreate a temporary <code>ChunkedArray</code> from a slice.\nReturns a reference to the <code>Field</code> name.\nCreates a new <code>Field</code>.\nOnly implemented for the same types and physical types!\nGet a reference to the physical array (the categories).\nCreate <code>ChunkedArray</code> with samples from a Bernoulli …\nRegisters a value to a categorical index without pushing …\nCheck if the categoricals have a compatible mapping\nSets the <code>Field</code> name.\nReturned a sorted <code>ChunkedArray</code>.\nCast <code>AnyValue</code> to the provided data type and return a new …\nGather values from ChunkedArray by index.\nGather values from ChunkedArray by index.\nGather values from ChunkedArray by index.\nConvert to an Arrow data type.\nConverts the <code>Field</code> to an <code>arrow::datatypes::Field</code>.\nConvert to an Arrow Field\nConvert an <code>StringChunked</code> to a <code>Series</code> of <code>DataType::Decimal</code>. …\nConvert a categorical column to its local representation.\nSafety\nSet the logical type of the <code>ListChunked</code>.\nReturns <code>&amp;self</code> for all but <code>ArrowDataType::Extension</code>. For …\nIf all nested <code>Series</code> have the same length, a 2 dimensional …\nConvert to the physical data type\nConvert the datatype of the array into the physical …\nConvert the datatype of the list into the physical …\nthe <code>PhysicalType</code> of this <code>ArrowDataType</code>.\nSafety\nAppend a new category, but fail if it didn’t exist yet …\nAppend a new category, but fail if it didn’t exist yet …\nTry apply a closure <code>F</code> elementwise.\nTry apply a closure <code>F</code> to each array.\nCast <code>AnyValue</code> to the provided data type and return a new …\nReturn whether or not the <code>CategoricalChunked</code> uses the …\nSafety\nReturns this <code>Field</code>, renamed.\nZip with a <code>ChunkedArray</code> then apply a binary function <code>F</code> …\nZip with a <code>ChunkedArray</code> then apply a binary function <code>F</code> …\nHashmap: maps the indexes from the global …\nUtf8Array: caches the string values and a hash of all …\nHashmap: maps the indexes from the global …\nUtf8Array: caches the string values and a hash of all …\nEnable the global string cache as long as the object is …\nDisable and clear the global string cache.\nEnable the global string cache.\nCheck whether the global string cache is enabled.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nHashmap: maps the indexes from the global …\nUtf8Array: caches the string values and a hash of all …\nEnable the global string cache as long as the object is …\nDisable and clear the global string cache.\nEnable the global string cache.\nCheck whether the global string cache is enabled.\nContains the error value\nContains the success value\nConstant that help with creating error messages dependent …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the function that will be called by the <code>polars_warn!</code> …\nPython hooks SIGINT to instead generate a …\nRuns the passed function, catching any KeyboardInterrupts …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nChecks if the keyboard interrupt flag is set, and if yes …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nKeep any of the unique rows This allows more optimizations\nA contiguous growable collection of <code>Series</code> that have the …\nKeep the first unique row.\nKeep the last unique row.\nKeep None of the unique rows.\nSame as <code>filter</code> but does not parallelize.\nThis will not panic even in debug mode - there are some …\nThe schema names must match the column names of this …\nCreate a <code>DataFrame</code> that has fields for all the known …\nEnsure all the chunks in the <code>DataFrame</code> are aligned.\nApply a closure to a column. This is the recommended way …\nApply a closure to a column at index <code>idx</code>. This is the …\nAggregate all the chunks in the DataFrame to a single …\nAggregate all the chunks in the DataFrame to a single …\nSplit DataFrame into chunks in preparation for writing. …\nRemove all the columns in the <code>DataFrame</code> but keep the <code>height</code>…\nSelect a single column by name.\nExtend the columns without checking for name collisions or …\nSelected multiple columns by name.\nDrop a column by name. This is a pure method and will …\nRemove a column by name and return the column removed.\nDrop columns that are in <code>names</code>.\nDrop columns that are in <code>names</code> without allocating a <code>HashSet</code>…\nReturn a new <code>DataFrame</code> where all null values are dropped.\nGet the data types of the columns in the <code>DataFrame</code>.\nCreates an empty <code>DataFrame</code> usable in a compile time …\nCreate an empty <code>DataFrame</code> with empty columns as per the …\nCreates an empty <code>DataFrame</code> with a specific <code>height</code>.\nCreate an empty <code>DataFrame</code> with empty columns as per the …\nCheck if <code>DataFrame</code>s are equal. Note that <code>None == None</code> …\nCheck if all values in <code>DataFrame</code>s are equal where …\nReturns an estimation of the total (heap) allocated size …\nExplode <code>DataFrame</code> to long format by exploding a column …\nExtend the memory backed by this <code>DataFrame</code> with the values …\nGet a reference to the schema fields of the <code>DataFrame</code>.\nReplace None values with one of the following strategies:\nTake the <code>DataFrame</code> rows by a boolean mask.\nThe number of chunks for the first column.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPanics\nPanics\nCreate a new <code>DataFrame</code> from rows. This should only be used …\nCreate a new <code>DataFrame</code> from rows.\nCreate a new <code>DataFrame</code> from an iterator over rows.\nCreate a new <code>DataFrame</code> with the given schema, only …\nGet a row in the <code>DataFrame</code>. Beware this is slow.\nGet column index of a <code>Series</code> by name.\nExample\nGet the <code>Vec&lt;PlSmallStr&gt;</code> representing the column names.\nGet a reference to the <code>DataFrame</code> columns.\nGet mutable access to the underlying columns.\nGet a row from a <code>DataFrame</code>. Use of this is discouraged as …\nAmortize allocations by reusing a row. The caller is …\nAmortize allocations by reusing a row. The caller is …\nGet the supertype of the columns in this DataFrame\nGroup DataFrame using a Series column.\nGroup DataFrame using a Series column. The groups are …\nHash and combine the row values\nGet the head of the <code>DataFrame</code>.\nGet the height of the <code>DataFrame</code> which is the number of …\nAdd multiple <code>Series</code> to a <code>DataFrame</code>. The added <code>Series</code> are …\nAdd multiple <code>Column</code> to a <code>DataFrame</code>. Errors if the …\nAdd columns horizontally.\nInsert a new column at a given index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet a mask of all the duplicated rows in the <code>DataFrame</code>.\nReturns <code>true</code> if the <code>DataFrame</code> contains no rows.\nGet a mask of all the unique rows in the <code>DataFrame</code>.\nIterator over the columns as <code>Series</code>.\nIterator over the rows in this <code>DataFrame</code> as Arrow …\nIterator over the rows in this <code>DataFrame</code> as Arrow …\nThe highest number of chunks for any column.\nCreate a DataFrame from a Vector of Series.\nCreate a new <code>DataFrame</code> but does not check the length or …\nCreate a new <code>DataFrame</code> but does not check the length or …\nConverts a sequence of columns into a DataFrame, …\nConverts a sequence of columns into a DataFrame, …\nConverts a sequence of columns into a DataFrame, …\nCreate a new <code>DataFrame</code> that shows the null counts per …\nSplit into multiple DataFrames partitioned by groups\nSplit into multiple DataFrames partitioned by groups Order …\nPipe different functions/ closure operations that work on …\nPipe different functions/ closure operations that work on …\nPipe different functions/ closure operations that work on …\nRemoves the last <code>Series</code> from the <code>DataFrame</code> and returns it, …\nRechunks all columns to only have a single chunk.\nRechunks all columns to only have a single chunk and turns …\nRename a column in the <code>DataFrame</code>.\nReplace a column with a <code>Series</code>.\nReplace column at index <code>idx</code> with a <code>Series</code>.\nReplace or update a column. The difference between this …\nGet a <code>DataFrame</code> with all the columns in reversed order.\nSample a fraction between 0.0-1.0 of this <code>DataFrame</code>.\nSample n datapoints from this <code>DataFrame</code>.\nGet the <code>DataFrame</code> schema.\nCheck if <code>DataFrame</code>’ schemas are equal.\nSelect column(s) from this <code>DataFrame</code> and return a new …\nSelect a <code>Series</code> by index.\nSelect column(s) from this <code>DataFrame</code> by range and return a …\nSelect column(s) from this <code>DataFrame</code> and return them into …\nSelect with a known schema. The schema names must match …\nSelect with a known schema without checking for duplicates …\nSet the column names.\nSet the height (i.e. number of rows) of this <code>DataFrame</code>.\nGet (height, width) of the <code>DataFrame</code>.\nShift the values by a given period and fill the parts that …\nReturns true if the chunks of the columns do not align and …\nShrink the capacity of this DataFrame to fit its length.\nReturns the size as number of rows * number of columns\nSlice the <code>DataFrame</code> along the rows.\nReturn a sorted clone of this <code>DataFrame</code>.\nSort <code>DataFrame</code> in place.\nSplit <code>DataFrame</code> at the given <code>offset</code>.\nGet the tail of the <code>DataFrame</code>.\nTake <code>DataFrame</code> rows by index values.\nTake ownership of the underlying columns vec.\nSafety\nSafety\nSafety\nSafety\nCreate a 2D <code>ndarray::Array</code> from this <code>DataFrame</code>. This …\nTranspose a DataFrame. This is a very expensive operation.\nApply a closure that may fail to a column. This is the …\nApply a closure that may fail to a column at index <code>idx</code>. …\nCreate a new <code>DataFrame</code> from an iterator over rows. This …\nGet column index of a <code>Series</code> by name.\nUnstable distinct. See <code>DataFrame::unique_stable</code>.\nDrop duplicate rows from a <code>DataFrame</code>. <em>This fails when </em>…\nEnsure all equal height and names are unique.\nConcatenate a <code>DataFrame</code> to this <code>DataFrame</code> and return as …\nConcatenate a <code>DataFrame</code> to this <code>DataFrame</code>\nConcatenate a <code>DataFrame</code> to this <code>DataFrame</code>\nConcatenate a <code>DataFrame</code> to this <code>DataFrame</code>\nGet the width of the <code>DataFrame</code> which is the number of …\nAdd a new column to this <code>DataFrame</code> or replace an existing …\nAdd a new column to this <code>DataFrame</code> or replace an existing …\nAdds a column to the <code>DataFrame</code> without doing any checks on …\nAdd a new column at index 0 that counts the rows.\nAdd a row index column in place.\nExtends this builder with the contents of the given …\nReturns the argument unchanged.\nExtends this builder with the contents of the given …\nCalls <code>U::from(self)</code>.\nExtends this builder with the contents of the given …\nExtends this builder with the contents of the given …\nA column within a <code>DataFrame</code>.\nConvert <code>Self</code> into a <code>Column</code>\nA <code>Column</code> that consists of a repeated <code>Scalar</code>\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nPacks every element into a list.\nGet the <code>ScalarColumn</code> as <code>Series</code>\nGet a reference to a <code>Series</code> for this <code>Column</code>\nIf the memory repr of this Column is a scalar, a …\nTake the <code>ScalarColumn</code> as a series with a <code>n</code> values.\nTake the <code>ScalarColumn</code> as a series with a single value.\nSafety\nSafety\nCreate a boolean mask by checking for equality.\nCreate a boolean mask by checking for equality.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSafety\nCreate a new <code>ScalarColumn</code> from a <code>length=1</code> Series and …\nSafety\nCreate a boolean mask by checking if self &gt; rhs.\nCreate a boolean mask by checking if self &gt;= rhs.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTurn <code>Column</code> into a <code>Column::Series</code>.\nGet the <code>ScalarColumn</code> as <code>Series</code> if it was already …\nCreate a boolean mask by checking if self &lt; rhs.\nCreate a boolean mask by checking if self &lt;= rhs.\nCreate a boolean mask by checking for inequality.\nCreate a boolean mask by checking for inequality.\nResize the <code>ScalarColumn</code> to new <code>length</code>.\nReturns whether the flags were set\nTake the <code>ScalarColumn</code> and materialize as a <code>Series</code> if not …\nTake <code>Series</code> from a <code>Column</code>\nSafety\nSafety\nMaterialize the <code>ScalarColumn</code> into a <code>Series</code>.\nCreate a new <code>ScalarColumn</code> from a <code>length=1</code> Series and …\nArguments for <code>LazyFrame::unpivot</code> function\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturned by a group_by operation on a DataFrame. This …\nIndexes of the groups, the first index is stored …\nEvery group is indicated by an array where the\nUsed to create the tuples for a group_by operation.\nSlice is always sorted in ascending order.\nAggregate the groups of the group_by operation into lists.\nApply a closure over the groups as a new <code>DataFrame</code>.\nAggregate grouped series and compute the number of values …\nAggregate grouped <code>Series</code> and find the first value per …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the internal representation of the GroupBy operation. …\nGet the internal representation of the GroupBy operation. …\nCreate the tuples need for a group_by operation. * The …\nCreate the tuples need for a group_by operation. * The …\nGet the group_by group indexes.\nGet a mutable reference to the <code>GroupsIdx</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAggregate grouped <code>Series</code> and return the last value per …\nAggregate grouped series and compute the maximum value per …\nAggregate grouped series and compute the mean per group.\nAggregate grouped <code>Series</code> and determine the median per …\nAggregate grouped series and compute the minimal value per …\nAggregate grouped <code>Series</code> by counting the number of unique …\nApply a closure over the groups as a new <code>DataFrame</code> in …\nAggregate grouped <code>Series</code> and determine the quantile per …\nSelect the column(s) that should be aggregated. You can …\nAggregate grouped <code>Series</code> and determine the standard …\nAggregate grouped series and compute the sum per group.\nSafety\nGet a reference to the <code>GroupsIdx</code>.\nGet a reference to the <code>GroupsSlice</code>.\nAggregate grouped <code>Series</code> and determine the variance per …\nHelper that combines the groups into a parallel iterator …\nSame helper as <code>_agg_helper_idx</code> but for aggregations that …\nSafety\nAn <code>AnyValueBuffer</code> that should be used when we trust the …\nSafety\nWill add the <code>AnyValue</code> into <code>Self</code> and unpack as the physical …\nCoerces a slice of datatypes into a single supertype.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nClear <code>self</code> and give <code>capacity</code>, returning the old contents …\nInfer schema from rows and set the first no null type as …\nInfer the schema of rows by determining the supertype of …\nInfer the schema data types of rows by determining the …\nConcat <code>DataFrame</code>s diagonally. Concat diagonally thereby …\nConcat <code>DataFrame</code>s horizontally. Concat horizontally and …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCompute the hash for all values in the array.\nCompute the hash for all values in the array.\nA thread-safe reference-counting pointer. ‘Arc’ stands …\nRepresents Arrow’s metadata of a “column”.\nAn ordered sequence of <code>Field</code>s\nAggregations that return <code>Series</code> of unit length. Those can …\nContains the error value\nHashmap: maps the indexes from the global …\nUtf8Array: caches the string values and a hash of all …\nContains the success value\nString type that inlines small strings.\nUtility trait to slice concrete arrow arrays whilst …\nEnable the global string cache as long as the object is …\nReturns a reference to the underlying allocator.\nProvides a raw pointer to the data.\nConverts to <code>Arc&lt;T&gt;</code>.\nConverts to <code>Arc&lt;[T]&gt;</code>.\nSet the labels at the center of the window.\nChecked integer division. Computes self / rhs, returning …\nMakes a clone of the <code>Arc</code> pointer.\nComparison for two <code>Arc</code>s.\nCast null arrays to inner type and ensure that all offsets …\nDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nCreates an empty CStr inside an Arc\nCreates an empty str inside an Arc\nCreates an empty <code>[T]</code> inside an Arc\nCreates a new <code>Arc&lt;T&gt;</code>, with the <code>Default</code> value for <code>T</code>.\nAttempts to downcast the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a …\nDowncasts the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a concrete …\nCreates a new <code>Weak</code> pointer to this allocation.\nDrops the <code>Arc</code>.\nReturns the <code>Field</code>’s <code>ArrowDataType</code>.\nIts logical <code>ArrowDataType</code>\nEquality for two <code>Arc</code>s.\nOptional parameters for the rolling\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a <code>&amp;mut CStr</code> into a <code>Arc&lt;CStr&gt;</code>, by copying the …\nAllocates a reference-counted <code>str</code> and copies <code>v</code> into it.\nMove a boxed object to a new, reference-counted allocation.\nAllocates a reference-counted <code>str</code> and copies <code>v</code> into it.\nConverts an <code>OsString</code> into an Arc&lt;OsStr&gt; by moving the …\nReturns the argument unchanged.\nConverts a <code>PathBuf</code> into an Arc&lt;Path&gt; by moving the <code>PathBuf</code> …\nConverts a <code>Path</code> into an <code>Arc</code> by copying the <code>Path</code> data into …\nCopies the string into a newly allocated Arc&lt;OsStr&gt;.\nAllocates a reference-counted slice and moves <code>v</code>’s items …\nConverts a <code>&amp;CStr</code> into a <code>Arc&lt;CStr&gt;</code>, by copying the contents …\nCreates an atomically reference-counted pointer from a …\nConverts a <code>Path</code> into an <code>Arc</code> by copying the <code>Path</code> data into …\nCopies the string into a newly allocated Arc&lt;OsStr&gt;.\nConverts a <code>T</code> into an <code>Arc&lt;T&gt;</code>\nConverts a <code>[T; N]</code> into an <code>Arc&lt;[T]&gt;</code>.\nAllocates a reference-counted slice and fills it by …\nConverts an atomically reference-counted string slice into …\nAllocates a reference-counted slice and fills it by …\nAllocates a reference-counted <code>str</code> and copies <code>v</code> into it.\nConverts a <code>CString</code> into an Arc&lt;CStr&gt; by moving the <code>CString</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSafety\nSafety\nTakes each element in the <code>Iterator</code> and collects it into an …\nCreate a list-array from an iterator. Used in group_by …\nSafety\nCreate a list-array from an iterator. Used in group_by …\nCreate a list-array from an iterator. Used in group_by …\nCreate a list-array from an iterator. Used in group_by …\nConstructs an <code>Arc&lt;T&gt;</code> from a raw pointer.\nConstructs an <code>Arc&lt;T, A&gt;</code> from a raw pointer.\nInitialize by name and values.\n‘Greater than or equal to’ comparison for two <code>Arc</code>s.\nReturns a mutable reference into the given <code>Arc</code>, if there …\nReturns a mutable reference into the given <code>Arc</code>, without …\nGreater-than comparison for two <code>Arc</code>s.\nIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the reference-counted slice into a …\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nConsumes the <code>Arc</code>, returning the wrapped pointer.\nConsumes the <code>Arc</code>, returning the wrapped pointer and …\nIts nullability\n‘Less than or equal to’ comparison for two <code>Arc</code>s.\nLess-than comparison for two <code>Arc</code>s.\nMakes a mutable reference into the given <code>Arc</code>.\nGet the max of the <code>ChunkedArray</code> as a new <code>Series</code> of length …\nGet the max of the <code>ChunkedArray</code> as a new <code>Series</code> of length …\nGet the median of the <code>ChunkedArray</code> as a new <code>Series</code> of …\nAdditional custom (opaque) metadata.\nAmount of elements in the window that should be filled …\nGet the min of the <code>ChunkedArray</code> as a new <code>Series</code> of length …\nGet the min of the <code>ChunkedArray</code> as a new <code>Series</code> of length …\nIts name\nInequality for two <code>Arc</code>s.\nTranslate the negative index to an offset.\nInitialize by name and values.\nConstructs a new <code>Arc&lt;T&gt;</code>.\nCreates a new <code>Field</code>.\nConstructs a new <code>Arc&lt;T&gt;</code> while giving you a <code>Weak&lt;T&gt;</code> to the …\nConstructs a new <code>Arc&lt;T, A&gt;</code> in the given allocator while …\nConstructs a new <code>Arc&lt;T&gt;</code> in the provided allocator.\nConstructs a new <code>Arc</code> with uninitialized contents.\nConstructs a new <code>Arc</code> with uninitialized contents in the …\nConstructs a new atomically reference-counted slice with …\nConstructs a new atomically reference-counted slice with …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new atomically reference-counted slice with …\nConstructs a new atomically reference-counted slice with …\nPartial comparison for two <code>Arc</code>s.\nConstructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>…\nConstructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator. …\nGet the product of the <code>ChunkedArray</code> as a new <code>Series</code> of …\nGet the product of the <code>ChunkedArray</code> as a new <code>Series</code> of …\nReturns <code>true</code> if the two <code>Arc</code>s point to the same allocation …\nGet the quantile of the <code>ChunkedArray</code> as a new <code>Series</code> of …\nSlices this <code>Array</code>.\nSlices the <code>Array</code>.\nGet the standard deviation of the <code>ChunkedArray</code> as a new …\nGets the number of strong (<code>Arc</code>) pointers to this …\nGet the sum of the <code>ChunkedArray</code> as a new <code>Series</code> of length …\nGet the sum of the <code>ChunkedArray</code> as a new <code>Series</code> of length …\nConstructs a new <code>Arc&lt;T&gt;</code>, returning an error if allocation …\nConstructs a new <code>Arc&lt;T, A&gt;</code> in the provided allocator, …\nConstructs a new <code>Arc</code> with uninitialized contents, …\nConstructs a new <code>Arc</code> with uninitialized contents, in the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>, return an error if …\nConstructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator, …\nChecks if the keyboard interrupt flag is set, and if yes …\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nIf we have the only reference to <code>T</code> then unwrap it. …\nGet the variance of the <code>ChunkedArray</code> as a new <code>Series</code> of …\nGets the number of <code>Weak</code> pointers to this allocation.\nAn optional slice with the same length as the window that …\nThe length of the window.\nCreates a new <code>Field</code> with metadata.\nSafety\nSafety\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nHashmap: maps the indexes from the global …\nUtf8Array: caches the string values and a hash of all …\nUtility trait to slice concrete arrow arrays whilst …\nSlices this <code>Array</code>.\nSlices the <code>Array</code>.\nEnable the global string cache as long as the object is …\nDisable and clear the global string cache.\nEnable the global string cache.\nCheck whether the global string cache is enabled.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTurn a scalar into a column with <code>length=1</code>.\nLook up the name in the schema and return an owned <code>Field</code> …\nIterates the <code>Field</code>s in this schema, constructing them anew …\nSelect fields using a bitmap.\nConvert self to <code>ArrowSchema</code> by cloning the fields.\nTake another <code>Schema</code> and try to find the supertypes between …\nLook up the name in the schema and return an owned <code>Field</code> …\nUsed to convert a <code>ChunkedArray</code>, <code>&amp;dyn SeriesTrait</code> and <code>Series</code>\nSeries\nReturns the sum of the array as an f64.\nReturns the sum of the array as an f64.\nSafety\nCreate a new Series without checking if the inner dtype of …\nGet the bitwise AND of the Series as a new Series of …\nGet the bitwise AND of the Series as a new Series of …\nAppend in place. This is done by adding the chunks of <code>other</code>…\nAppend in place. This is done by adding the chunks of <code>other</code>…\nRetrieve the indexes needed for a sort.\nRetrieve the indexes needed for a sort.\nGet first indexes of unique values.\nGet first indexes of unique values.\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Array</code>\nReturns a reference to the Arrow ArrayRef\nGet a hold of the <code>ChunkedArray</code>, <code>Logical</code> or <code>NullChunked</code> as …\nGet a hold of the <code>ChunkedArray</code>, <code>Logical</code> or <code>NullChunked</code> as …\nPacks every element into a list.\nGet a hold of the <code>ChunkedArray</code> or <code>NullChunked</code> as an <code>Any</code> …\nRechunk and return a pointer to the start of the Series. …\nRechunk and return a pointer to the start of the Series. …\nOnly implemented for numeric types\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Binary</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Binary</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Boolean</code>\nCast from physical to logical types without any checks on …\nCast <code>Series</code> to another <code>DataType</code>.\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Categorical</code>\nGet the lengths of the underlying chunks\nUnderlying chunks.\nUnderlying chunks.\nSafety\nClone inner ChunkedArray and wrap in a new Arc\nRedo a length and null_count compute\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Decimal</code>\nDrop all null values and return a new Series.\nDrop all null values and return a new Series.\nGet datatype of series.\nGet datatype of series.\nCreate a boolean mask by checking for equality.\nCreate a boolean mask by checking for equality.\nCheck if series are equal. Note that <code>None == None</code> …\nCheck if all values in series are equal where <code>None == None</code> …\nReturns an estimation of the total (heap) allocated size …\nExplode a list Series. This expands every item to a new …\nExtend the memory backed by this array with the values …\nExtend with a constant value.\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Float32</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Float64</code>\nGet field (used in schema)\nGet field (used in schema)\nReplace None values with one of the following strategies:\nFilter by boolean mask. This operation clones data.\nGet the first element of the <code>Series</code> as a <code>Scalar</code>\nGet the first element of the <code>Series</code> as a <code>Scalar</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a new <code>Series</code> from a slice of AnyValues.\nConstruct a new <code>Series</code> with the given <code>dtype</code> from a slice …\nTakes chunks and a polars datatype and constructs the …\nConvert a non-logical series back into a logical series …\nTraverse and collect every nth element in a new array.\nGet a single value by index. Don’t use this operation …\nGet a single value by index. Don’t use this operation …\nRecurse nested types until we are at the leaf array.\nGet the value at this index as a downcastable Any trait …\nGet the value at this index as a downcastable Any trait …\nGet the value at this index as a downcastable Any trait …\nGet the value at this index as a downcastable Any trait …\nGet a single value by index. Don’t use this operation …\nCreate a boolean mask by checking if self &gt; rhs.\nCreate a boolean mask by checking if self &gt;= rhs.\nReturn if any the chunks in this <code>ChunkedArray</code> have nulls.\nGet the head of the Series.\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Int128</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Int16</code>\nUnpack to <code>ChunkedArray</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Int64</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Int8</code>\nConvert the values of this Series to a ListChunked with a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if Series is empty.\nCheck if Series is empty.\nCheck if numeric value is finite\nCheck if numeric value is infinite\nCheck if numeric value is NaN (note this is different than …\nCheck if numeric value is NaN (note this is different than …\nGet a mask of the non-null values.\nGet a mask of the null values.\niterate over <code>Series</code> as <code>AnyValue</code>.\nGet the last element of the <code>Series</code> as a <code>Scalar</code>\nGet the last element of the <code>Series</code> as a <code>Scalar</code>\nGet length of series.\nTake <code>num_elements</code> from the top as a zero copy view.\nTake <code>num_elements</code> from the top as a zero copy view.\nUnpack to <code>ChunkedArray</code> of dtype list\nTODO: Move this somewhere else?\nFor ListArrays, recursively normalizes the offsets to …\nCreate a boolean mask by checking if self &lt; rhs.\nCreate a boolean mask by checking if self &lt;= rhs.\nReturns the maximum value in the array, according to the …\nGet the max of the Series as a new Series of length 1.\nGet the max of the Series as a new Series of length 1.\nReturns the mean value in the array Returns an option …\nReturns the mean value in the array Returns an option …\nReturns the median value in the array Returns an option …\nReturns the median value in the array Returns an option …\nGet the median of the Series as a new Series of length 1.\nGet the median of the Series as a new Series of length 1.\nReturns the minimum value in the array, according to the …\nGet the min of the Series as a new Series of length 1.\nGet the min of the Series as a new Series of length 1.\nNumber of chunks in this Series\nNumber of chunks in this Series\nGet unique values in the Series.\nGet unique values in the Series.\nName of series.\nConstruct a new <code>Series</code> from a collection of <code>AnyValue</code>.\nCreate a new empty Series.\nCreate a new Series filled with values from the given …\nCreate a boolean mask by checking for inequality.\nCreate a boolean mask by checking for inequality.\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Null</code>\nCount the null values.\nGet the bitwise OR of the Series as a new Series of length …\nGet the bitwise OR of the Series as a new Series of length …\nGet the product of an array.\nGet the quantile of the ChunkedArray as a new Series of …\nGet the quantile of the ChunkedArray as a new Series of …\nAggregate all chunks to a contiguous array of memory.\nRename the Series.\nRename series.\nreturn a Series in reversed order\nApply a custom function over a rolling/ moving window of …\nApply a custom function over a rolling/ moving window of …\nSample a fraction between 0.0-1.0 of this <code>ChunkedArray</code>.\nShift the values by a given period and fill the parts that …\nShrink the capacity of this array to fit its length.\nShrink the capacity of this array to fit its length.\nShrink the capacity of this array to fit its length.\nGet a zero copy view of the data.\nSort the series with specific options.\nGet a zero copy view of the data.\nReturns the std value in the array Returns an option …\nReturns the std value in the array Returns an option …\nGet the standard deviation of the Series as a new Series …\nGet the standard deviation of the Series as a new Series …\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::String</code>\nCast throws an error if conversion had overflows\nCompute the sum of all values in this Series. Returns …\nGet the sum of the Series as a new Scalar.\nGet the sum of the Series as a new Scalar.\nGet the sum of the Series as a new Series of length 1. …\nGet the tail of the Series.\nTake from <code>self</code> at the indexes given by <code>idx</code>.\nTake or clone a owned copy of the inner <code>ChunkedArray</code>.\nTake from <code>self</code> at the indexes given by <code>idx</code>.\nTake from <code>self</code> at the indexes given by <code>idx</code>.\nTake from <code>self</code> at the indexes given by <code>idx</code>.\nConvert a chunk in the Series to the correct Arrow type. …\nCast numerical types to f64, and keep floats as is.\nConverts a Series to their physical representation, if …\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Array</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Binary</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Binary</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Boolean</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Categorical</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Decimal</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Float32</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Float64</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Int128</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Int16</code>\nUnpack to <code>ChunkedArray</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Int64</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Int8</code>\nUnpack to <code>ChunkedArray</code> of dtype list\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::Null</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::String</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::UInt16</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::UInt32</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::UInt64</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::UInt8</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::UInt16</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::UInt32</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::UInt64</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>DataType::UInt8</code>\nGet unique values in the Series.\nGet unique values in the Series.\nCompute the unique elements, but maintain order. This …\nReturns the var value in the array Returns an option …\nReturns the var value in the array Returns an option …\nGet the variance of the Series as a new Series of length 1.\nGet the variance of the Series as a new Series of length 1.\nReturn this Series with a new name.\nGet the bitwise XOR of the Series as a new Series of …\nGet the bitwise XOR of the Series as a new Series of …\nCreate a new ChunkedArray with values from self where the …\nA <code>Series</code> that amortizes a few allocations during iteration.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSwaps inner state with the <code>array</code>. Prefer …\nTemporary swaps out the array, and restores the original …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecked integer division. Computes self / rhs, returning …\nChecked integer division. Computes self / rhs, returning …\nChecked integer division. Computes self / rhs, returning …\nA type-erased wrapper around ArrayBuilder.\nExtends this builder with the contents of the given …\nReturns the argument unchanged.\nExtends this builder with the contents of the given series …\nCalls <code>U::from(self)</code>.\nExtends this builder with the contents of the given series …\ndrop nulls\nignore nulls\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nImplode lists to match nesting types.\nAllow casting of primitive types (numeric, bools) to …\nConvenience for <code>x.into_iter().map(Into::into).collect()</code> …\nJust a wrapper structure which is useful for certain impl …\nThis takes ownership of the DataFrame so that drop is …\nThis takes ownership of the DataFrame so that drop is …\nEnsure the chunks in both ChunkedArrays have the same …\nPanics\nGet a flags value with all known bits set.\nDetermine the supertype of a collection of <code>AnyValue</code>.\nDetermine the supertype and the number of unique data …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nensure that nulls are propagated to both arrays\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nConcat the DataFrames to a single DataFrame.\nConcat the DataFrames to a single DataFrame.\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nConvert a collection of <code>DataType</code> into a schema.\nGiven multiple data types, determine the data type that …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nReturns a numeric supertype that <code>l</code> and <code>r</code> can be safely …\nGiven two data types, determine the data type that both …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nCreate a new <code>TrustMyLength</code> iterator\nCreate a new <code>TrustMyLength</code> iterator that repeats <code>value</code> <code>len</code> …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nSplits, but doesn’t flatten chunks. E.g. a container can …\nSplit a <code>Container</code> in <code>target</code> elements. The target doesn’t …\nSplit a <code>DataFrame</code> in <code>target</code> elements. The target doesn’t …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nTurn any iterator in a trusted length iterator\nGiven two data types, determine the data type that both …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nA utility that allocates an <code>AmortSeries</code>. The applied …")